import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,b as d,a as e,e as o,d as n,w as i,r as s,o as p}from"./app-Hf0KJrif.js";const c={},u={class:"hint-container warning"},m={class:"hint-container caution"};function h(g,t){const a=s("RouteLink");return p(),l("div",null,[t[27]||(t[27]=d('<h2 id="一-知识铺垫" tabindex="-1"><a class="header-anchor" href="#一-知识铺垫"><span>[一]知识铺垫</span></a></h2><blockquote><p>自动数据初始化，需要了解一定的 <code>Spring Data JPA</code> 知识，如果对此还不了解，请先阅读 <a href="https://www.herodotus.vip/get-started/install/" target="_blank" rel="noopener noreferrer">Spring Data JPA 数据初始化机制</a></p></blockquote><h2 id="二-操作步骤" tabindex="-1"><a class="header-anchor" href="#二-操作步骤"><span>[二]操作步骤</span></a></h2><p><strong>Dante Cloud</strong> 数据库表创建和默认数据的初始化，就是使用 <code>Spring Data JPA</code> 自身的机制实现。</p><p>在 <strong>Dante Cloud</strong> 数据库表创建和默认数据的初始化过程中, 主要会进行以下几项操作。</p><ul><li>创建核心业务表</li><li>扫描已运行服务中所有的<code>RestController</code>接口，将接口数据转换为权限数据，并汇总至用户中心服务统一存储和管理。</li><li>系统默认数据，如用户,角色等数据的初始化。</li></ul>',6)),e("div",u,[t[2]||(t[2]=e("p",{class:"hint-container-title"},"注意",-1)),e("p",null,[t[1]||(t[1]=o("具体开始之前，一定要确保所有前序工作已经完成。参阅：")),n(a,{to:"/guide/get-start/deployment.html#%E5%90%8E%E7%AB%AF%E8%BF%90%E8%A1%8C"},{default:i(()=>t[0]||(t[0]=[o("数据库初始化前序工作")])),_:1})])]),t[28]||(t[28]=e("h3",{id:"步骤一-创建数据表",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#步骤一-创建数据表"},[e("span",null,"步骤一：创建数据表")])],-1)),t[29]||(t[29]=e("h4",{id:"_1-进入-nacos-管理界面。找到您所使用的对应-多环境-下的-dante-cloud-environment-yaml-配置文件",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-进入-nacos-管理界面。找到您所使用的对应-多环境-下的-dante-cloud-environment-yaml-配置文件"},[e("span",null,[o("1. 进入 Nacos 管理界面。找到您所使用的对应 "),e("code",null,"多环境"),o(" 下的 "),e("code",null,"dante-cloud-environment.yaml"),o(" 配置文件")])])],-1)),e("p",null,[t[4]||(t[4]=o("例如，您当前使用的是 ")),t[5]||(t[5]=e("code",null,"development",-1)),t[6]||(t[6]=o(" 环境，那么在 Nacos 后台管理中，找到 ")),t[7]||(t[7]=e("code",null,"Group",-1)),t[8]||(t[8]=o(" 是 ")),t[9]||(t[9]=e("code",null,"development",-1)),t[10]||(t[10]=o(" 的 ")),t[11]||(t[11]=e("code",null,"dante-cloud-environment.yaml",-1)),t[12]||(t[12]=o(" 配置。多环境配置，参阅：")),n(a,{to:"/guide/backend/profile-design.html"},{default:i(()=>t[3]||(t[3]=[o("多环境配置")])),_:1})]),t[30]||(t[30]=d('<h4 id="_2-设置-dante-cloud-environment-yaml配置文件中属性-herodotus-switch-database-ddl-auto-的值为-create-或-update" tabindex="-1"><a class="header-anchor" href="#_2-设置-dante-cloud-environment-yaml配置文件中属性-herodotus-switch-database-ddl-auto-的值为-create-或-update"><span>2. 设置 <code>dante-cloud-environment.yaml</code>配置文件中属性 <code>herodotus.switch.database.ddl-auto</code> 的值为 <code>create</code> 或 <code>update</code></span></a></h4><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li>如果是初次部署，或者想将已有表重新创建，那么将 <code>herodotus.switch.database.ddl-auto</code> 的值设置为 <code>create</code>。</li><li>如果是已经开始使用系统了，想保留已有的数据，只做更新，那么将 <code>herodotus.switch.database.ddl-auto</code> 的值设置为 <code>update</code>。</li></ul></div><h4 id="_3-点击发布按钮-发布配置-让配置生效" tabindex="-1"><a class="header-anchor" href="#_3-点击发布按钮-发布配置-让配置生效"><span>3. 点击<code>发布</code>按钮，发布配置，让配置生效</span></a></h4>',3)),e("div",m,[t[26]||(t[26]=e("p",{class:"hint-container-title"},"警告",-1)),e("ul",null,[t[24]||(t[24]=e("li",null,[e("p",null,[e("strong",null,"正式环境一定要提前做好数据备份"),o("。")])],-1)),t[25]||(t[25]=e("li",null,[e("p",null,[o("如果是"),e("code",null,"MySQL"),o("数据库的初次部署，那么最好将 "),e("code",null,"herodotus.switch.database.ddl-auto"),o(" 的值设置为 "),e("code",null,"update"),o("，否则就会出错。")])],-1)),e("li",null,[e("p",null,[t[14]||(t[14]=e("code",null,"herodotus.switch.database.ddl-auto",-1)),t[15]||(t[15]=o(" 的值设置为 ")),t[16]||(t[16]=e("code",null,"update",-1)),t[17]||(t[17]=o(", 再次运行服务，由于 ")),t[18]||(t[18]=e("code",null,"Hibernate",-1)),t[19]||(t[19]=o(" 不同方言实现逻辑的不同，在有些数据库下运行，例如：")),t[20]||(t[20]=e("code",null,"PostgreSQL",-1)),t[21]||(t[21]=o(", 对于某些兼容性问题，只是输出告警；在某些数据库下运行，例如 MySQL，对于某些兼容性问题，会直接抛出 Exception。所以出现这种情况，只要服务继续在运行就不是系统 BUG；如果出错直接导致服务运行停止，那么请报 ")),t[22]||(t[22]=e("code",null,"ISSUE",-1)),t[23]||(t[23]=o("。参阅：")),n(a,{to:"/others/question/mysql.html"},{default:i(()=>t[13]||(t[13]=[o("MySQL 常见问题")])),_:1})])])])]),t[31]||(t[31]=d('<h4 id="_4-运行-upmsapplication-服务" tabindex="-1"><a class="header-anchor" href="#_4-运行-upmsapplication-服务"><span>4. 运行 <code>UpmsApplication</code> 服务</span></a></h4><p><code>UpmsApplication</code> 服务第一次正常运行之后，所有核心业务表都已经创建，<code>UpmsApplication</code> 服务中所有接口都已经转换为权限数据存入<code>sys_attribute</code>表中。</p><blockquote><p>如果看到有数据库表创建，同时<code>sys_authority</code>表中有数据，证明数据库表创建成功。</p></blockquote><h4 id="_5-运行-uaaapplication-服务" tabindex="-1"><a class="header-anchor" href="#_5-运行-uaaapplication-服务"><span>5. 运行 <code>UaaApplication</code> 服务</span></a></h4><p><code>UaaApplication</code> 服务第一次正常运行之后，所有 OAuth2 认证相关表都已经创建。<code>UaaApplication</code> 服务中所有接口都已经转换为权限数据存入<code>sys_attribute</code>表中。</p><blockquote><p>如果看到有以<code>oauth2_</code>开头的数据表创建，证明数据库表创建成功。</p></blockquote><h4 id="_6-运行-messageapplication-服务" tabindex="-1"><a class="header-anchor" href="#_6-运行-messageapplication-服务"><span>6. 运行 <code>MessageApplication</code> 服务</span></a></h4><p><code>MessageApplication</code> 服务第一次正常运行之后，所有站内消息等相关表都已经创建。<code>MessageApplication</code> 服务中所有接口都已经转换为权限数据存入<code>sys_attribute</code>表中。</p><blockquote><p>如果看到有以<code>msg_</code>开头的数据表创建，证明数据库表创建成功。</p></blockquote><h4 id="_7-运行-ossabilityapplication-服务" tabindex="-1"><a class="header-anchor" href="#_7-运行-ossabilityapplication-服务"><span>7. 运行 <code>OssAbilityApplication</code> 服务</span></a></h4><p><code>OssAbilityApplication</code> 服务第一次正常运行之后，<code>OssAbilityApplication</code> 服务中所有接口都已经转换为权限数据存入<code>sys_attribute</code>表中。</p><div class="hint-container info"><p class="hint-container-title">为什么表结构的创建不提供脚本？</p><p>主要出于以下考虑：</p><ul><li>一方面系统默认使用 Spring Data JPA 已经支持了自动建表，数据表的创建和更新都很方便，仅有的问题对于 MySQL 方言支持的一般，会有错误提示，但是不影响整体初始化逻辑。</li><li>另一方面微服务架构相比单体应用来说庞大得多，需要关注的内容也扩展了很多倍。提供数据库表结构的脚本，就意味随时要去关注这个 SQL 脚本的更新问题，一旦有遗漏就很容出错，会浪费很多时间和精力，得不偿失。</li></ul></div><h3 id="步骤二-初始默认数据" tabindex="-1"><a class="header-anchor" href="#步骤二-初始默认数据"><span>步骤二：初始默认数据</span></a></h3><div class="hint-container info"><p class="hint-container-title">说明</p><p>系统提供自动初始化和手动初始化数据库两种方式。</p><p>自动化初始化数据库的机制完全由 Spring Data JPA 提供，使用习惯之后非常便捷。但是项目开源至今，发现很多人还是喜欢手动导数据，也提供了数据库初始化脚本。也正因为如此，也修改了本部分说明，主要说明手动导入数据，自动导入数据仅做说明供对此感兴趣的朋友参考。</p></div><div class="hint-container warning"><p class="hint-container-title">注意</p><p>要按照前面步骤，保证 <code>UpmsApplication</code>、<code>UaaApplication</code>、<code>MessageApplication</code>、<code>OssAbilityApplication</code> 几个服务均已经正常运行过、服务中所有接口都已经转换为权限数据存入<code>sys_attribute</code>表中以后，在执行数据库初始化脚本。</p><p>因为，数据库初始化脚本中，最后一条 SQL 语句，是根据 <code>sys_attribute</code> 表中存储的数据，动态生成权限数据。如果过早执行数据库初始化脚本，会导致权限数据创建不完整，前端出现“没有权限”提示问题。</p></div><h4 id="方式一-手动初始化" tabindex="-1"><a class="header-anchor" href="#方式一-手动初始化"><span>方式一：手动初始化</span></a></h4><ol><li><p>设置 <code>dante-cloud-environment.yaml</code> 配置文件中属性 <code>herodotus.switch.database.ddl-auto</code> 的值为 <code>update</code> 或 <code>none</code>。</p></li><li><p>在工程<code>${project_home}/platform/dante-cloud-oss-ability/resources/sqls</code>目录下，可以找到对应数据库数据初始化脚本。可以用你喜欢的方式导入数据库。</p></li></ol><h4 id="方式二-自动初始化" tabindex="-1"><a class="header-anchor" href="#方式二-自动初始化"><span>方式二：自动初始化</span></a></h4><ol><li><p>停止<code>OssAbilityApplication</code>服务</p></li><li><p>进入 Nacos 管理界面。找到您所使用的对应 <code>多环境</code> 下的 <code>dante-cloud-environment.yaml</code> 配置文件。</p></li><li><p>设置 <code>dante-cloud-environment.yaml</code> 配置文件中属性 <code>herodotus.switch.database.ddl-auto</code> 的值为 <code>update</code> 或 <code>none</code></p></li><li><p>设置 <code>dante-cloud-environment.yaml</code> 配置文件中属性 <code>herodotus.switch.database.init-mode</code> 的值为 <code>always</code></p></li><li><p>点击<code>发布</code>按钮，发布配置，让配置生效。</p></li><li><p>如果默认使用的不是 <code>PostgreSQL</code> 数据库，需要修改<code>${project_home}/platform/dante-cloud-oss-ability/resources/bootstrap.yml</code> 中 <code>spring.sql.init.data-locations</code> 配置，放开您所使用数据库对应的 SQL 脚本。注释掉其它 SQL 脚本</p></li><li><p>再次运行 <code>OssAbilityApplication</code> 服务。</p></li></ol><p><code>OssAbilityApplication</code> 服务再一次正常运行之后，如果<code>sys_user</code>,<code>sys_role</code>,<code>sys_role_permission</code>等表中都都已经有数据了，证明数据初始化成功。</p><h3 id="步骤三-回置配置" tabindex="-1"><a class="header-anchor" href="#步骤三-回置配置"><span>步骤三：回置配置</span></a></h3><ol><li><p>停止<code>OssAbilityApplication</code> 服务</p></li><li><p>进入 Nacos 管理界面。找到您所使用的对应 <code>多环境</code> 下的 <code>dante-cloud-environment.yaml</code> 配置文件。</p></li><li><p>设置 <code>dante-cloud-environment.yaml</code> 配置文件中属性 <code>herodotus.switch.database.init-mode</code> 的值重置为 <code>never</code>。</p></li><li><p>检查 <code>dante-cloud-environment.yaml</code> 配置文件中属性 <code>herodotus.switch.database.ddl-auto</code> 的值为 <code>update</code> 或 <code>none</code></p></li><li><p>点击<code>发布</code>按钮，发布配置，让配置生效。</p></li></ol><div class="hint-container tip"><p class="hint-container-title">为什么回置并再次检查？</p><ul><li>如果 <code>herodotus.switch.database.ddl-auto</code> 的值为 <code>create</code> 或 <code>create-drop</code>，再次启动服务会重新建表，那么前面的工作就白做了。</li><li>如果 <code>herodotus.switch.database.init-mode</code> 的值为 <code>always</code>，再次启动服务会再次执行 SQL 脚本，必定出现主键冲突问题导致失败。</li></ul></div><h2 id="三-重置缓存" tabindex="-1"><a class="header-anchor" href="#三-重置缓存"><span>[三]重置缓存</span></a></h2><div class="hint-container caution"><p class="hint-container-title">警告</p><p>所以为了规避因缓存原因而产生让人莫名奇妙的问题，在以上步骤均完成之后（<strong>数据库初始化完成之后</strong>），一定要按照以下步骤进行缓存重置</p><ol><li>停止所有服务</li><li>清空 Redis 缓存数据</li><li>再次运行所有服务</li></ol></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>经过实际的使用，总体感受 <code>Spring Data JPA</code> 以及 <code>Hibernate</code> 的多数据库支持还是非常强大，在 <code>PostgreSQL</code> 等自身版本差异不大的数据库家族中，使用非常顺滑。而像<code>MySQL</code> 这种自身各个版本差异较大的数据库家族中，使用起来确实有点蹩脚。</p><h2 id="配置参数对应关系" tabindex="-1"><a class="header-anchor" href="#配置参数对应关系"><span>配置参数对应关系</span></a></h2><p><strong>Dante Cloud</strong> 数据库操作设计配置参数与<code>spring-boot-starter-data-jpa</code>配置参数对应关系如下表：</p><table><thead><tr><th>配置</th><th>对应</th></tr></thead><tbody><tr><td>herodotus.database-information.driver-class-name</td><td>spring.datasource.driver-class-name</td></tr><tr><td>herodotus.database-information.url</td><td>spring.datasource.url</td></tr><tr><td>herodotus.environment.database.username</td><td>spring.datasource.username</td></tr><tr><td>herodotus.environment.database.password</td><td>spring.datasource.password</td></tr><tr><td>herodotus.database-information.platform</td><td>spring.jpa.database<br>spring.sql.init.platform</td></tr><tr><td>herodotus.environment.database.dialect</td><td>spring.jpa.properties.hibernate.dialect</td></tr><tr><td>herodotus.switch.database.ddl-auto</td><td>spring.jpa.hibernate.ddl-auto</td></tr><tr><td>herodotus.switch.database.init-mode</td><td>spring.sql.init.mode</td></tr></tbody></table>',30))])}const S=r(c,[["render",h]]),A=JSON.parse('{"path":"/guide/backend/data-initialization.html","title":"数据初始化","lang":"zh-CN","frontmatter":{"icon":"caret-right","title":"数据初始化","tag":["SAS","Spring Authorization Server","Dante Cloud","微服务","领域驱动","DDD","Spring Boot","Spring Cloud","Spring Security","Spring Cloud Alibaba","Spring Cloud Tencent","OAuth2.1","Nacos","Skywalking","Sentinel","Seata"],"description":"[一]知识铺垫 自动数据初始化，需要了解一定的 Spring Data JPA 知识，如果对此还不了解，请先阅读 Spring Data JPA 数据初始化机制 [二]操作步骤 Dante Cloud 数据库表创建和默认数据的初始化，就是使用 Spring Data JPA 自身的机制实现。 在 Dante Cloud 数据库表创建和默认数据的初始化过...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据初始化\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-11T02:26:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"码匠君\\",\\"url\\":\\"https://gitee.com/dromara/dante-cloud\\"}]}"],["meta",{"property":"og:url","content":"https://dante-cloud.dromara.org/guide/backend/data-initialization.html"}],["meta",{"property":"og:site_name","content":"“一套代码、两种架构”基于Apache2.0开源协议的企业级微服务"}],["meta",{"property":"og:title","content":"数据初始化"}],["meta",{"property":"og:description","content":"[一]知识铺垫 自动数据初始化，需要了解一定的 Spring Data JPA 知识，如果对此还不了解，请先阅读 Spring Data JPA 数据初始化机制 [二]操作步骤 Dante Cloud 数据库表创建和默认数据的初始化，就是使用 Spring Data JPA 自身的机制实现。 在 Dante Cloud 数据库表创建和默认数据的初始化过..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-11T02:26:33.000Z"}],["meta",{"property":"article:tag","content":"Seata"}],["meta",{"property":"article:tag","content":"Sentinel"}],["meta",{"property":"article:tag","content":"Skywalking"}],["meta",{"property":"article:tag","content":"Nacos"}],["meta",{"property":"article:tag","content":"OAuth2.1"}],["meta",{"property":"article:tag","content":"Spring Cloud Tencent"}],["meta",{"property":"article:tag","content":"Spring Cloud Alibaba"}],["meta",{"property":"article:tag","content":"Spring Security"}],["meta",{"property":"article:tag","content":"Spring Cloud"}],["meta",{"property":"article:tag","content":"Spring Boot"}],["meta",{"property":"article:tag","content":"DDD"}],["meta",{"property":"article:tag","content":"领域驱动"}],["meta",{"property":"article:tag","content":"微服务"}],["meta",{"property":"article:tag","content":"Dante Cloud"}],["meta",{"property":"article:tag","content":"Spring Authorization Server"}],["meta",{"property":"article:tag","content":"SAS"}],["meta",{"property":"article:modified_time","content":"2025-05-11T02:26:33.000Z"}],["meta",{"name":"keywords","content":"SAS,Spring Authorization Server,Dante Cloud,微服务,DDD,Spring Boot,Spring Cloud,Spring Cloud Alibaba,Spring Cloud Tencent,Nacos,WebFlux,RSocket,GPRC,Minio"}],["script",{},"var _hmt = _hmt || [];\\n            (function() {\\n              var hm = document.createElement(\\"script\\");\\n              hm.src = \\"https://hm.baidu.com/hm.js?9d06530da5dbac9ce977a65ddf8e1cc0\\";\\n              var s = document.getElementsByTagName(\\"script\\")[0]; \\n              s.parentNode.insertBefore(hm, s);\\n            })();"]]},"git":{"createdTime":1746930393000,"updatedTime":1746930393000,"contributors":[{"name":"码匠君","username":"","email":"pointer_v@qq.com","commits":1}]},"readingTime":{"minutes":6.9,"words":2070},"filePathRelative":"guide/backend/data-initialization.md","autoDesc":true}');export{S as comp,A as data};
